from packages import *
from PowerAero import *
from PowerGrav import *
from PowerRolling import *
from BTI_Live_Output import *
from ArrayPower import *
from BatteryModel import *
from VelocityProfile import *
from Optimization_Routine import *
from Plotter import *
from simulator_constants import *

#July 30th to August 6th racing days.
#Note: For each racing day k the initial condition for the optimizer velocity is Vk,o= 0 always.
#number_of_wheels= 4


'''Note to self: Still left to debug:
   1) For every Excel sheet with the ASC route data you need
   to check the initial condition (first segment in the file) and think
   about whether resistive losses need to be estimated for that segment.
   2) Array Model and Battery Models still need to be incorporated.
   
   Racing interval for each racing day is 9 am to 6 pm. (9 hours)
   Charging period is 4 hours. (7:9 am and 6:8 pm)
   
   stage stops occur at end of: road data: 2,4,7.
   checkpoints occur at end of: road data: 1, 3, 5, 6
   End of competition: road data: 8
   
   Charging averages:
   
   7-8 am: 1314.52276504 W. 8-9 am: 1558.53867978 W.
   
   6pm to 7pm: 1197.24342046 W. 7:8pm: 352.2345747 W. (ballpark value for 7-8 pm)
   
   checkpoints charging time for 45 minutes.
     
   '''
   
class Race_Simulator():
    
    def __init__(self,v_profile_type):
    #Constants required for a race simulation.
        self.v_profile_type= v_profile_type
        self.delta_t= list()
        self.altitude=list()
        self.p_aero= list()
        self.p_roll=list()
        self.p_grav=list()
        self.p_resistive=list()
        self.p_resistive_watthour=list()
        self.step=list()
        self.total_time=list()
        self.ti=list()
        self.ti_amend=list()
        self.p_array_driving=list()
        self.p_array_charging=list()
        self.p_bat=list()
        self.p_bat_watthour=list()
        self.error_bound= 0.001
        self.time_profile=list()
        self.p_bat_watthour_req= list()
        self.race_bat_capacity_energy_daily=list()
        self.p_array_driving_list=list()
        self.p_array_driving_list_watthour=list()
        self.high_noon_angles_1= np.zeros((len(f_hill_data), 1))
        self.high_noon_angles_2= np.zeros((len(f_hill_data), 1))
        self.average_angles= np.zeros((len(f_hill_data), 1))
        self.flag=0
        self.velocity_si= None
        self.velocity_kph= None
        self.p_array_watthour_required= list()
        self.race_days=None
        self.race_bat_capacity_energy= None
        self.incline_array=list()
        self.max_indices=list()
    def Run_Simulation(self):
        #Option to simulate with the same constant speed throughout the entire race.
        if self.v_profile_type == "constant_full":
            self.velocity_si= Generate_Constant_Velocity_Profile(73.0, "si")
            self.velocity_kph= Generate_Constant_Velocity_Profile(73.0, "kph")
        for i in range (0, len(f_hill_data)):
            delta_t_day= (f_hill_data[i].iloc[:,2]*1000)/(self.velocity_si[i].flatten())
            self.delta_t.append(delta_t_day)
            altitude_day= calculate_air(f_hill_data[i].iloc[:, 5])
            self.altitude.append(altitude_day)
            #Calculate aero losses.
            p_aero_day= calculate_paero(frontal_area, self.velocity_si[i].flatten(), 0, Cd, altitude_day)
            self.p_aero.append(p_aero_day)
            #Calculate rolling resistance losses.
            p_roll_day= calculate_power_roll(mass_of_car, gravity, (f_hill_data[i].iloc[:,6]/1000.0), f_hill_data[i].iloc[:,2], self.velocity_kph[i].flatten(), roll_coefficient)
            self.p_roll.append(p_roll_day)
            #Calculate gravity losses.
            p_grav_day= f_hill_data[i].iloc[:,9] * self.velocity_si[i].flatten()
            self.p_grav.append(p_grav_day)
            #Calculate instantaneous power generated by the array.
            self.high_noon_angles_1[i]= Calculate_High_Noon_Sun_Angle((race_day_start+i), f_hill_data[i].iloc[0,10])
            self.high_noon_angles_2[i]= Calculate_High_Noon_Sun_Angle((race_day_start+i), f_hill_data[i].iloc[(f_hill_data[i].shape[0]-1),10])
            self.average_angles[i]= Calculate_Average_High_Noon_Sun_Angle(self.high_noon_angles_1[i],self.high_noon_angles_2[i])        
            #Time required to complete the race. ADDED Copy function. may cause bugs.
            total_time_day= delta_t_day.copy().sum()
            self.total_time.append(total_time_day)
            #Total resistive forces losses.
            p_resistive_day= ((p_aero_day + p_roll_day + p_grav_day)/n_motor) + electrical_parasitic_losses
            self.p_resistive.append(p_resistive_day)
            self.step.append(f_hill_data[i].iloc[:,0])
            #Total resistive forces losses in WattHours.
            p_resistive_watthour_daily= p_resistive_day * (delta_t_day)/3600.0
            p_resistive_watthour_daily_sum= p_resistive_watthour_daily.copy().sum()
            self.p_resistive_watthour.append(p_resistive_watthour_daily_sum)
            print("\n\n\n Race day " +str(i+1) + " begins!\n\n\n")
            if i in [5]:
                #Active checkpoints charging for 45 mins. Edge case.
                race_bat_capacity_energy= race_bat_capacity_energy + bat_efficiency*Array_Power_Driving_day.flatten()[0]*checkpoint_duration
                if (race_bat_capacity_energy > bat_capacity):
                    race_bat_capacity_energy = bat_capacity
                print("\n\n\n Charging at special checkpoints!!! Battery capacity at the beginning of the race day is: " + str(race_bat_capacity_energy))
        #Calculating the array power.
            if((f_hill_data[i]['Stage Stop'][(f_hill_data[i]['Stage Stop'].shape[0])-1])=='yes'):
                time_profile_day= ((f_hill_data[i].iloc[:,1]*1000)/(self.velocity_si[i].flatten()))/3600.0
                self.time_profile.append(time_profile_day)
                ti_day= time_profile_day+self.ti[i-1][self.ti[i-1].shape[0]-1]+checkpoint_duration #accounted for checkpoint duration.
                ti_day= Check_Time_Collisions(ti_day, driving_start_time,driving_end_time,f_hill_data[i], self.velocity_si[i])
                self.ti.append(ti_day[0])
                sun_angles_day= Calculate_Sun_Angle(ti_day[0], SR[0], DL, self.average_angles[i])
                Array_Power_Driving_day= Array_Power_Driving_Cloud_Factor(n_array, n_mppt, n_cloud, area_array, solar_irradiance,  sun_angles_day)
                self.p_array_driving.append(Array_Power_Driving_day)
                #45 minutes of charging at checkpoint.
                race_bat_capacity_energy= race_bat_capacity_energy + bat_efficiency*Array_Power_Driving_day.flatten()[0]*checkpoint_duration
                if (race_bat_capacity_energy > bat_capacity):
                    race_bat_capacity_energy = bat_capacity          
            elif((f_hill_data[i]['Checkpoint'][(f_hill_data[i]['Checkpoint'].shape[0])-1])== 'yes'):
                #print(str(i) + " occurs as a checkpoint. ")
                time_profile_day= ((f_hill_data[i].iloc[:,1]*1000)/(self.velocity_si[i].flatten()))/3600.0
                self.time_profile.append(time_profile_day)
                if i in [0,2,4]: #Starting time should be at 9am on the first day.
                    if i==0:
                        #Start with a full battery pack on first day.
                        race_bat_capacity_energy= bat_capacity                  
                        ti_day= time_profile_day + driving_start_time
                    else:
                        #remaining battery capacity + morning charge time after each non-end stage stop.
                        race_bat_capacity_energy= race_bat_capacity_energy + bat_efficiency*(1314.52276504 + 1558.53867978) #2 hours of charge time.
                        if (race_bat_capacity_energy > bat_capacity):
                            race_bat_capacity_energy = bat_capacity
                        print("Morning charging occuring on day: " + str(i+1))
                        ti_day= time_profile_day + driving_start_time
                else: #on any other day we need to fetch the time from the previous day.
                    ti_day= time_profile_day + self.ti[i-1][self.ti[i-1].shape[0]-1] + checkpoint_duration
                ti_day= Check_Time_Collisions(ti_day, driving_start_time,driving_end_time,f_hill_data[i], self.velocity_si[i])
                self.ti.append(ti_day[0])
                sun_angles_day= Calculate_Sun_Angle(ti_day[0], SR[0], DL, self.average_angles[i])
                Array_Power_Driving_day= Array_Power_Driving_Cloud_Factor(n_array, n_mppt, n_cloud, area_array, solar_irradiance,  sun_angles_day)
                self.p_array_driving.append(Array_Power_Driving_day)
            elif((f_hill_data[i]['Checkpoint'][(f_hill_data[i]['Checkpoint'].shape[0])-1])== 'end'):
                time_profile_day= ((f_hill_data[i].iloc[:,1]*1000)/(self.velocity_si[i].flatten()))/3600.0
                self.time_profile.append(time_profile_day)
                print("Morning charging occuring on day: " + str(i+1))
                race_bat_capacity_energy= race_bat_capacity_energy + bat_efficiency*(1314.52276504 + 1558.53867978)
                if (race_bat_capacity_energy > bat_capacity):
                    race_bat_capacity_energy = bat_capacity
                print("Total battery pack on last day: " + str(race_bat_capacity_energy))
                ti_day= time_profile_day+driving_start_time
                ti_day= Check_Time_Collisions(ti_day, driving_start_time,driving_end_time,f_hill_data[i], self.velocity_si[i])
                self.ti.append(ti_day[0])
                sun_angles_day= Calculate_Sun_Angle(ti_day[0], SR[0], DL, self.average_angles[i])
                Array_Power_Driving_day= Array_Power_Driving_Cloud_Factor(n_array, n_mppt, n_cloud, area_array, solar_irradiance,  sun_angles_day)
                self.p_array_driving.append(Array_Power_Driving_day)
            p_array_driving_watthour= Array_Power_Driving_day.flatten() * (delta_t_day)/3600.0
            self.p_array_driving_list_watthour.append(p_array_driving_watthour)
            self.p_array_watthour_required.append(p_array_driving_watthour.copy().sum())
            print("Starting energy in the battery pack on day " + str(i+1) + " : " + str(race_bat_capacity_energy))
            p_bat_daily= Calculate_Required_Battery_Power(Array_Power_Driving_day.flatten(), p_aero_day, p_roll_day, p_grav_day, n_motor, electrical_parasitic_losses, bat_efficiency)
            self.p_bat.append(p_bat_daily)
            p_bat_daily_capacity= p_bat_daily * (delta_t_day)/3600.0
            self.p_bat_watthour_req.append(p_bat_daily_capacity)
            if np.where(p_bat_daily_capacity.as_matrix() < 0)[0].shape[0] is not 0:
                p_bat_capacity_daily_copy= p_bat_daily_capacity.copy()
                bat_indexes_charging= np.where(p_bat_daily_capacity.as_matrix() < 0)[0]
                bat_indexes_losses= np.where(p_bat_daily_capacity.as_matrix() > 0)[0]
                negative_energy= bat_efficiency * p_bat_capacity_daily_copy[bat_indexes_charging]
                #print(negative_energy)
                #print(p_bat_capacity_daily_copy[bat_indexes_losses])
                net_energy= negative_energy.sum() + p_bat_capacity_daily_copy[bat_indexes_losses].sum()
                if net_energy < 0:  #YOU CHARGE THAT BATTERY!
                    race_bat_capacity_energy += abs(net_energy)
                    if race_bat_capacity_energy > bat_capacity:
                        race_bat_capacity_energy = bat_capacity
                else: #YOU USE UP THAT BATTERY ENERGY!
                    race_bat_capacity_energy -= net_energy
                    if race_bat_capacity_energy <= 0:
                        print("We goofed with our battery on day: " + str(i+1))
                        self.flag=1
            print("Energy in the pack remaining after day " + str(i+1) + " : "+str(race_bat_capacity_energy) + " before charging.\n")
            self.p_bat_watthour.append(p_bat_daily_capacity.sum())
            if i in [1,3,6]: #we will not charge in the afternoon on the last day so i=7 can be ignored.
                race_bat_capacity_energy= race_bat_capacity_energy + bat_efficiency*(1197.24342046 + 352.2345747)
                if (race_bat_capacity_energy > bat_capacity):
                    race_bat_capacity_energy = bat_capacity
                print("Energy in the pack remaining after day " + str(i+1) + " : "+str(race_bat_capacity_energy) + " after stage stop charging.\n")
        self.race_days= ti_day[1]
        self.race_bat_capacity_energy= race_bat_capacity_energy
        return 0
    def Plot_Incline_Profile(self):
        #Plot the incline profile for the race.
        path= os.getcwd()
        '''Create a directory to save the plots.'''
        dir_path= path+ "\Incline_Data"
        if not os.path.exists(dir_path):
            os.makedirs(dir_path)
        os.chdir(dir_path)
        for i in range (0, len(f_hill_data)):
            incline_day= np.arcsin(f_hill_data[i].iloc[:,9]/ (mass_of_car * gravity))
            #Round to nearest integer!
            self.incline_array.append(np.around(incline_day.as_matrix(), decimals=2) * 100.0)
            #plt.figure(num=i+1)
            print("Results for incline")
            values= np.around(incline_day.as_matrix(), decimals=2) * 100.0
            print(values)
            #plt.hist(values)
            #plt.title(ASC_Route_Names[i] + " Incline Profile")
            #plt.xlabel("Incline Angle Value (Rounded)")
            #plt.ylabel("Frequency of the road incline")
            #plt.savefig(ASC_Route_Names[i] + ".jpg")
            index= np.where(values > 5)[0]
            self.max_indices.append(index)
        os.chdir(path)
        return 0
    def Display_Results(self):
        if self.flag == 0:    
            print("\n\n\nSimulation has terminated succesfully! Here are the results! \n\n\n")
            print("Total Racing Days is: "+str(self.race_days))
            #Plot_Data_Constant_Velocity(p_resistive, step, velocity_kph[0][0])
            #Plot_Data_Constant_Velocity(p_array_driving, step, velocity_kph[0][0])
            #Plot_Data_Constant_Velocity(p_bat_watthour_req, step, velocity_kph[0][0])
            #plt.close(1)
            print("\n\n\n")
            print("Total time to finish the race with a velocity of " + str(self.velocity_kph[0][0]) + " km/h in hours: ")
            ellapsed_time= sum(self.total_time)/3600.0    
            print(ellapsed_time)
    
            print("\n\n\n Energy required to overcome resistive forces each day in Watthour: ")
            print(self.p_resistive_watthour)
    
            print("\n\n\n Energy generated by the array each day in Watthour: ")
            print(self.p_array_watthour_required)
    
            print("\n\n\n Energy provided by battery each day in Watthour: ")
            print(self.p_bat_watthour)
    
            print("\n\n\n Final Energy left in the pack after the race in Watthour: ")
            print(self.race_bat_capacity_energy)
            print("\n\n\n")
        else:
            print("\n\n\nSimulation has failed since we deplete our battery pack early!")
            print("Check Simulation information for details of failure.")
        return 0
    def Reset_Results(self):
        self.delta_t= list()
        self.altitude=list()
        self.p_aero= list()
        self.p_roll=list()
        self.p_grav=list()
        self.p_resistive=list()
        self.p_resistive_watthour=list()
        self.step=list()
        self.total_time=list()
        self.ti=list()
        self.ti_amend=list()
        self.p_array_driving=list()
        self.p_array_charging=list()
        self.p_bat=list()
        self.p_bat_watthour=list()
        self.error_bound= 0.001
        self.time_profile=list()
        self.p_bat_watthour_req= list()
        self.race_bat_capacity_energy_daily=list()
        self.p_array_driving_list=list()
        self.p_array_driving_list_watthour=list()
        self.high_noon_angles_1= np.zeros((len(f_hill_data), 1))
        self.high_noon_angles_2= np.zeros((len(f_hill_data), 1))
        self.average_angles= np.zeros((len(f_hill_data), 1))
        self.flag=0
        self.velocity_si= None
        self.velocity_kph= None
        self.p_array_watthour_required= list()
        self.race_days=None
        self.race_bat_capacity_energy= None
        self.incline_array=list()
        self.max_indices=list()
        
if __name__ == '__main__':
    
    b= Race_Simulator("constant_full")
    b.Run_Simulation()
    b.Display_Results()
    
    '''global f_hill_data
    #Overall Tester for the velocity profile.
    
    velocity_si= Generate_Constant_Velocity_Profile(65, "si")
    velocity_kph= Generate_Constant_Velocity_Profile(65, "kph")
    
    flag=0    
    
    high_noon_angles_1= np.zeros((len(f_hill_data), 1))
    high_noon_angles_2= np.zeros((len(f_hill_data),1))
    average_angles= np.zeros((len(f_hill_data),1))
    
    
    delta_t= list()
    altitude=list()
    p_aero=list()
    p_roll= list()
    p_grav=list()
    
    p_resistive=list()
    p_resistive_watthour=list()

    step=list()
    
    total_time=list()
    ti=list()
    ti_amend=list()
    driving_start_time=9.00
    driving_end_time= 18.00
         
    
    p_array_driving=list()
    p_array_charging=list()
    p_bat=list()
    p_bat_watthour=list()
    error_bound= 0.001
    time_profile=list()
    p_bat_watthour_req= list()
    race_bat_capacity_energy_daily=list()
    
    p_array_driving_list=list()
    p_array_driving_list_watthour=list()
        
    
    for i in range (0, len(f_hill_data)):
        delta_t_day= (f_hill_data[i].iloc[:,2]*1000)/(velocity_si[i].flatten())
        delta_t.append(delta_t_day)
        altitude_day= calculate_air(f_hill_data[i].iloc[:, 5])
        altitude.append(altitude_day)
        #Calculate aero losses.
        p_aero_day= calculate_paero(frontal_area, velocity_si[i].flatten(), 0, Cd, altitude_day)
        p_aero.append(p_aero_day)
        #Calculate rolling resistance losses.
        p_roll_day= calculate_power_roll(mass_of_car, gravity, (f_hill_data[i].iloc[:,6]/1000.0), f_hill_data[i].iloc[:,2], velocity_kph[i].flatten(), roll_coefficient)
        p_roll.append(p_roll_day)
        #Calculate gravity losses.
        p_grav_day= f_hill_data[i].iloc[:,9] * velocity_si[i].flatten()
        p_grav.append(p_grav_day)
        #Calculate instantaneous power generated by the array.
        high_noon_angles_1[i]= Calculate_High_Noon_Sun_Angle((race_day_start+i), f_hill_data[i].iloc[0,10])
        high_noon_angles_2[i]= Calculate_High_Noon_Sun_Angle((race_day_start+i), f_hill_data[i].iloc[(f_hill_data[i].shape[0]-1),10])
        average_angles[i]= Calculate_Average_High_Noon_Sun_Angle(high_noon_angles_1[i],high_noon_angles_2[i])        
        #Time required to complete the race.
        total_time_day= delta_t_day.sum()
        total_time.append(total_time_day)
        #Total resistive forces losses.
        p_resistive_day= ((p_aero_day + p_roll_day + p_grav_day)/n_motor) + electrical_parasitic_losses
        p_resistive.append(p_resistive_day)
        step.append(f_hill_data[i].iloc[:,0])
        #Total resistive forces losses in WattHours.
        p_resistive_watthour_daily= p_resistive_day * (delta_t_day)/3600.0
        p_resistive_watthour_daily_sum= p_resistive_watthour_daily.sum()
        p_resistive_watthour.append(p_resistive_watthour_daily_sum)
        print("\n\n\n Race day " +str(i+1) + " begins!\n\n\n")
        
        if i in [5]:
            #Active checkpoints charging for 45 mins. Edge case.
            race_bat_capacity_energy= race_bat_capacity_energy + bat_efficiency*Array_Power_Driving_day.flatten()[0]*checkpoint_duration
            if (race_bat_capacity_energy > bat_capacity):
                race_bat_capacity_energy = bat_capacity
            print("\n\n\n Charging at special checkpoints!!! Battery capacity at the beginning of the race day is: " + str(race_bat_capacity_energy))
        #Calculating the array power.
        if((f_hill_data[i]['Stage Stop'][(f_hill_data[i]['Stage Stop'].shape[0])-1])=='yes'):
            time_profile_day= ((f_hill_data[i].iloc[:,1]*1000)/(velocity_si[i].flatten()))/3600.0
            time_profile.append(time_profile_day)
            ti_day= time_profile_day+ti[i-1][ti[i-1].shape[0]-1]+checkpoint_duration
            ti_day= Check_Time_Collisions(ti_day, driving_start_time,driving_end_time,f_hill_data[i], velocity_si[i])
            ti.append(ti_day[0])
            sun_angles_day= Calculate_Sun_Angle(ti_day[0], SR[0], DL, average_angles[i])
            Array_Power_Driving_day= Array_Power_Driving_Cloud_Factor(n_array, n_mppt, n_cloud, area_array, solar_irradiance,  sun_angles_day)
            p_array_driving.append(Array_Power_Driving_day)
            #45 minutes of charging at checkpoint.
            race_bat_capacity_energy= race_bat_capacity_energy + bat_efficiency*Array_Power_Driving_day.flatten()[0]*checkpoint_duration
            if (race_bat_capacity_energy > bat_capacity):
                race_bat_capacity_energy = bat_capacity          
        elif((f_hill_data[i]['Checkpoint'][(f_hill_data[i]['Checkpoint'].shape[0])-1])== 'yes'):
            #print(str(i) + " occurs as a checkpoint. ")
            time_profile_day= ((f_hill_data[i].iloc[:,1]*1000)/(velocity_si[i].flatten()))/3600.0
            time_profile.append(time_profile_day)
            if i in [0,2,4]: #Starting time should be at 9am on the first day.
                if i==0:
                    #Start with a full battery pack on first day.
                    race_bat_capacity_energy= bat_capacity                  
                    ti_day= time_profile_day + driving_start_time
                else:
                    #remaining battery capacity + morning charge time after each non-end stage stop.
                    race_bat_capacity_energy= race_bat_capacity_energy + bat_efficiency*(1314.52276504 + 1558.53867978) #2 hours of charge time.
                    if (race_bat_capacity_energy > bat_capacity):
                        race_bat_capacity_energy = bat_capacity
                    print("Morning charging occuring on day: " + str(i+1))
                    ti_day= time_profile_day + driving_start_time
            else: #on any other day we need to fetch the time from the previous day.
                ti_day= time_profile_day + ti[i-1][ti[i-1].shape[0]-1] + checkpoint_duration
            ti_day= Check_Time_Collisions(ti_day, driving_start_time,driving_end_time,f_hill_data[i], velocity_si[i])
            ti.append(ti_day[0])
            sun_angles_day= Calculate_Sun_Angle(ti_day[0], SR[0], DL, average_angles[i])
            Array_Power_Driving_day= Array_Power_Driving_Cloud_Factor(n_array, n_mppt, n_cloud, area_array, solar_irradiance,  sun_angles_day)
            p_array_driving.append(Array_Power_Driving_day)
        elif((f_hill_data[i]['Checkpoint'][(f_hill_data[i]['Checkpoint'].shape[0])-1])== 'end'):
            time_profile_day= ((f_hill_data[i].iloc[:,1]*1000)/(velocity_si[i].flatten()))/3600.0
            time_profile.append(time_profile_day)
            print("Morning charging occuring on day: " + str(i+1))
            race_bat_capacity_energy= race_bat_capacity_energy + bat_efficiency*(1314.52276504 + 1558.53867978)
            if (race_bat_capacity_energy > bat_capacity):
                race_bat_capacity_energy = bat_capacity
            print("Total battery pack on last day: " + str(race_bat_capacity_energy))
            ti_day= time_profile_day+driving_start_time
            ti_day= Check_Time_Collisions(ti_day, driving_start_time,driving_end_time,f_hill_data[i], velocity_si[i])
            ti.append(ti_day[0])
            sun_angles_day= Calculate_Sun_Angle(ti_day[0], SR[0], DL, average_angles[i])
            Array_Power_Driving_day= Array_Power_Driving_Cloud_Factor(n_array, n_mppt, n_cloud, area_array, solar_irradiance,  sun_angles_day)
            p_array_driving.append(Array_Power_Driving_day)
        p_array_driving_watthour= Array_Power_Driving_day.flatten() * (delta_t_day)/3600.0
        p_array_driving_list_watthour.append(p_array_driving_watthour.sum())
        print("Starting energy in the battery pack on day " + str(i+1) + " : " + str(race_bat_capacity_energy))
        p_bat_daily= Calculate_Required_Battery_Power(Array_Power_Driving_day.flatten(), p_aero_day, p_roll_day, p_grav_day, n_motor, electrical_parasitic_losses, bat_efficiency)
        p_bat.append(p_bat_daily)
        p_bat_daily_capacity= p_bat_daily * (delta_t_day)/3600.0
        p_bat_watthour_req.append(p_bat_daily_capacity)
        if np.where(p_bat_daily_capacity.as_matrix() < 0)[0].shape[0] is not 0:
            p_bat_capacity_daily_copy= p_bat_daily_capacity.copy()
            bat_indexes_charging= np.where(p_bat_daily_capacity.as_matrix() < 0)[0]
            bat_indexes_losses= np.where(p_bat_daily_capacity.as_matrix() > 0)[0]
            negative_energy= bat_efficiency * p_bat_capacity_daily_copy[bat_indexes_charging]
            #print(negative_energy)
            #print(p_bat_capacity_daily_copy[bat_indexes_losses])
            net_energy= negative_energy.sum() + p_bat_capacity_daily_copy[bat_indexes_losses].sum()
            if net_energy < 0:  #YOU CHARGE THAT BATTERY!
                race_bat_capacity_energy += abs(net_energy)
                if race_bat_capacity_energy > bat_capacity:
                    race_bat_capacity_energy = bat_capacity
            else: #YOU USE UP THAT BATTERY ENERGY!
                race_bat_capacity_energy -= net_energy
                if race_bat_capacity_energy <= 0:
                    print("We goofed with our battery on day: " + str(i+1))
                    flag=1
        print("Energy in the pack remaining after day " + str(i+1) + " : "+str(race_bat_capacity_energy) + " before charging.\n")
        p_bat_watthour.append(p_bat_daily_capacity.sum())
        if i in [1,3,6]: #we will not charge in the afternoon on the last day so i=7 can be ignored.
            race_bat_capacity_energy= race_bat_capacity_energy + bat_efficiency*(1197.24342046 + 352.2345747)
            if (race_bat_capacity_energy > bat_capacity):
                race_bat_capacity_energy = bat_capacity
            print("Energy in the pack remaining after day " + str(i+1) + " : "+str(race_bat_capacity_energy) + " after stage stop charging.\n")
    
    if flag == 0:    
        print("\n\n\nSimulation has terminated succesfully! Here are the results! \n\n\n")
        print("Total Racing Days is: "+str(ti_day[1]))
        #Plot_Data_Constant_Velocity(p_resistive, step, velocity_kph[0][0])
        #Plot_Data_Constant_Velocity(p_array_driving, step, velocity_kph[0][0])
        #Plot_Data_Constant_Velocity(p_bat_watthour_req, step, velocity_kph[0][0])
        #plt.close(1)
        print("\n\n\n")
        print("Total time to finish the race with a velocity of " + str(velocity_kph[0][0]) + " km/h in hours: ")
        ellapsed_time= sum(total_time)/3600.0    
        print(ellapsed_time)
    
        print("\n\n\n Energy required to overcome resistive forces each day in Watthour: ")
        print(p_resistive_watthour)
    
        print("\n\n\n Energy generated by the array each day in Watthour: ")
        print(p_array_driving_list_watthour)
    
        print("\n\n\n Energy provided by battery each day in Watthour: ")
        print(p_bat_watthour)
    
        print("\n\n\n Final Energy left in the pack after the race in Watthour: ")
        print(race_bat_capacity_energy)
        print("\n\n\n")
    else:
        print("\n\n\nSimulation has failed since we deplete our battery pack early!")
        print("Check Simulation information for details of failure.")'''
    
